SUBROUTINE inverse(NEQ, S, SI)

	INTEGER :: i, LW, LIW, LRW, astatus
	INTEGER, INTENT(IN) :: NEQ
	INTEGER, ALLOCATABLE :: IWORK(:)
	DOUBLE PRECISIOn :: Sd(NEQ)
	DOUBLE PRECISION, ALLOCATABLE :: RWORK(:)
	DOUBLE COMPLEX, INTENT(INOUT) :: S(NEQ,NEQ)
	DOUBLE COMPLEX :: Sdm(NEQ,NEQ), U(NEQ,NEQ), VT(NEQ,NEQ), &
			  TMP(NEQ,NEQ)
	DOUBLE COMPLEX, INTENT(OUT) :: SI(NEQ,NEQ)
	DOUBLE COMPLEX, ALLOCATABLE :: WORK(:)


	LW = NEQ*( NEQ + 3 )
	LIW = 8 * NEQ
	LRW = NEQ * ( 5 * NEQ + 7 )
	ALLOCATE(WORK(LW), IWORK(LIW), RWORK(LRW), STAT=astatus)
	CALL ZGESDD( 'A', NEQ, NEQ, S, NEQ, Sd, U, NEQ, VT, NEQ, WORK, LW, RWORK, IWORK, INFO )

	Sdm(1:NEQ,1:NEQ) = (0.0D0, 0.0D0)
	DO i = 1, NEQ
		IF ( ABS( Sd(i) ) .LT. ( 64.0D0 * 10.0D-6 ) ) THEN
			Sdm(i,i) = Sd(i) + 10.0D-6 * EXP( -Sd(i) * 10.0D6)
		ELSE
			Sdm(i,i) = 1.0D0 / Sd(i)
		END IF
	END DO

!	TMP = MATMUL( Sdm, VT )
!	SI = MATMUL( TRANSPOSE( DCONJG( U ) ), MATMUL( Sdm, TRANSPOSE( DCONJG( Vt ) ) ) )
	SI = MATMUL( U, MATMUL( Sdm, Vt ) )

	RETURN
END SUBROUTINE inverse
