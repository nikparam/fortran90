SUBROUTINE inverse(NEQ, S, SI)

	INTEGER :: i, LW, LIW, LRW, astatus
	INTEGER, INTENT(IN) :: NEQ
	INTEGER, ALLOCATABLE :: IWORK(:)
	DOUBLE PRECISIOn :: Sd(NEQ)
	DOUBLE PRECISION, ALLOCATABLE :: RWORK(:)
	DOUBLE COMPLEX, INTENT(INOUT) :: S(NEQ,NEQ)
	DOUBLE COMPLEX :: Sdm(NEQ,NEQ), U(NEQ,NEQ), VT(NEQ,NEQ), &
			  TMP(NEQ,NEQ)
	DOUBLE COMPLEX, INTENT(OUT) :: SI(NEQ,NEQ)
	DOUBLE COMPLEX, ALLOCATABLE :: WORK(:)


	LW = NEQ*( NEQ + 3 )
	LIW = 8 * NEQ
	LRW = NEQ * ( 5 * NEQ + 7 )
	ALLOCATE(WORK(LW), IWORK(LIW), RWORK(LRW), STAT=astatus)
	CALL ZGESDD( 'A', NEQ, NEQ, S, NEQ, Sd, U, NEQ, VT, NEQ, WORK, LW, RWORK, IWORK, INFO )

	Sdm(1:NEQ,1:NEQ) = (0.0D0, 0.0D0)
	DO i = 1, NEQ
!		IF ( ABS( Sd(i) ) .LT. ( 64.0D0 * 10.0D-8 ) ) THEN
!			Sdm(i,i) = Sd(i) + 10.0D-8 * EXP( -Sd(i) * 10.0D8)
!			Sdm(i,i) = Sd(i) / ( Sd(i) * Sd(i) + 1e-8 )
!		ELSE
			Sdm(i,i) = 1.0D0 / Sd(i)
!		END IF
	END DO

	SI = MATMUL( TRANSPOSE( CONJG( VT ) ), MATMUL( Sdm, TRANSPOSE( CONJG( U ) ) ) )

	RETURN
END SUBROUTINE inverse
